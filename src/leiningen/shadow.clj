(ns leiningen.shadow
  (:require [clojure.string :as string]
            [clojure.edn :as edn]
            [clojure.java.io :as io]
            [clojure.java.shell :refer [sh]]
            [leiningen.core.main :as lein]
            [leiningen.core.eval :refer [eval-in-project]]
            [leiningen.run :as run]
            [meta-merge.core :refer [meta-merge]]
            [clojure.data.json :as json]
            #_[shadow.cljs.devtools.server.npm-deps :as npm-deps]))

(def ^:const run-shadow-cljs ["-m" "shadow.cljs.devtools.cli"])
(def ^:const shadow-config-preamble "
 ;;
 ;; >>>>>>>>>>>>>>>>>>>>>>>>>> DO NOT EDIT THIS FILE <<<<<<<<<<<<<<<<<<<<<<<<<<<
 ;;
 ;;
 ;;
 ;;
 ;;
 ;;
 ;; This file is generated by lein-shadow.
 ;; Any changes you make will be overwritten and lost.
 ;; Instead you should edit the value keyed :shadow-cljs in project.clj.
 ;;
 ;; More details: https://gitlab.com/nikperic/lein-shadow/-/tree/docs/shadow-cljs.edn.md
 ;;
 ;; Don't even check this file into your git repo. Add it to .gitignore.
 ;;
 ;;
 ;;
 ;;
 ;;
 ;;
 ;;
 ;; >>>>>>>>>>>>>>>>>>>>>>>> YOUR CHANGES WILL BE LOST <<<<<<<<<<<<<<<<<<<<<<<<<
 ;;
 ")
;; WARNING: A newline is required after the comment otherwise the entire
;;          configuration string will be commented out when concatenated.

(def windows? (string/starts-with? (System/getProperty "os.name") "Windows"))

(defn merge-shadow-config
  [shadow-config project-shadow-config]
  (meta-merge (dissoc shadow-config
                      :source-paths
                      :dependencies)
              project-shadow-config))

(defn merge-project
  [shadow-config project]
  (meta-merge (select-keys shadow-config [:source-paths :dependencies])
              project))

(def ^:const managed-regex #"This file is generated by lein-shadow")
(def ^:const shadow-config-backup-path "shadow-cljs.edn.backup")

(defn default-shadow-config-file
  []
  (io/file (System/getProperty "user.home") ".shadow-cljs" "config.edn"))

(defn read-default-shadow-config
  []
  (let [file (default-shadow-config-file)]
    (when (.exists file)
      (-> file slurp edn/read-string))))


(defn package-install-dir
  "Return the `:npm-deps :install-dir` from the `:shadow-cljs` configuration, or
   the current working directory if it does not exist."
  [shadow-config]
  (get-in shadow-config [:npm-deps :install-dir] lein/*cwd*))

(defn package-json-file
  [shadow-config]
  (io/file (package-install-dir shadow-config) "package.json"))

(defn package-lock-json-file
  [shadow-config]
  (io/file (package-install-dir shadow-config) "package-lock.json"))

(defn npm-shrinkwrap-json-file
  [shadow-config]
  (io/file (package-install-dir shadow-config) "npm-shrinkwrap.json"))

(defn yarn-lock-file
  [shadow-config]
  (io/file (package-install-dir shadow-config) "yarn.lock"))

(defn package-json-exists?
  [shadow-config]
  (.exists (package-json-file shadow-config)))

(defn package-locks-exist?
  "Returns true if package-lock.json or npm-shrinkwrap.json exist."
  [shadow-config]
  (or (.exists (package-lock-json-file shadow-config))
      (.exists (npm-shrinkwrap-json-file shadow-config))))

(defn yarn-lock-exists?
  [shadow-config]
  (.exists (yarn-lock-file shadow-config)))

(defn package-json-name
  [{:keys [group name] :as project}]
  (if (= name group) name (str group "." name)))

(defn node-package-manager
  [shadow-config]
  (or (get-in shadow-config [:node-modules :managed-by])
      (get-in shadow-config [:npm-deps :managed-by])
      (when (yarn-lock-exists? shadow-config)
        :yarn)
      :npm))

(defn package-manager-command
  [shadow-config]
  (conj
    (if windows?
      ["cmd" "/C"]
      [])
    (name (node-package-manager shadow-config))))

(def command-not-found-err
  (if windows?
    "is not recognized as an internal or external command"
    "command not found"))

(defn node-package-manager-sh!
  [shadow-config preamble package-manager-args]
  (let [command (into (package-manager-command shadow-config) package-manager-args)]
    (lein/info "lein-shadow - running:" (string/join " " command))
    (let [result (apply sh command)]
      (if (zero? (:exit result))
        (lein/info "lein-shadow -" preamble (:out result))
        (if (re-find (re-pattern command-not-found-err) (:err result))
          (let [command-type (node-package-manager shadow-config)
                command-name (name command-type)
                command-url  (case command-type
                               :npm "https://nodejs.org"
                               :yarn "https://classic.yarnpkg.com/"
                               (format "the documentation for '%s'" command-name))]
            (lein/abort (format "lein-shadow - '%s' could not be found. Make sure '%s' is installed and present in your PATH. See %s. Error output:\n" command-name command-name command-url) (:err result))
            (lein/abort (format "lein-shadow - '%s' exited with the unsuccessful exit code") (:exit result) "and the error output:\n" (:err result))))))))

(defn node-package-manager-version!
  [shadow-config]
  (node-package-manager-sh!
    shadow-config
    (format "'%s' version" (name (node-package-manager shadow-config)))
    ["--version"]))

(defn node-deps-map->vec
  [deps-map url annotations]
  (mapv
    (fn [[dep-id dep-version]]
      (merge
        annotations
        {:id dep-id
         :version dep-version
         :url url}))
    deps-map))

(defn read-node-deps-from-deps-cljs
  "Reads the first `deps.cljs` file found in `project` `:source-paths`, otherwise nil."
  [project]
  (reduce
    (fn [_ source-path]
      (when-let [deps-cljs-file (io/file source-path "deps.cljs")]
        (when (.exists deps-cljs-file)
          (lein/info "lein-shadow - reading node dependencies from" (.getCanonicalPath deps-cljs-file))
          (let [{:keys [npm-deps npm-dev-deps]} (-> deps-cljs-file (slurp) (edn/read-string))]
            (reduced
              (into
                (node-deps-map->vec npm-deps (str (.getCanonicalPath deps-cljs-file) "!:npm-deps") {:dev false})
                (node-deps-map->vec npm-dev-deps (str (.getCanonicalPath deps-cljs-file) "!:npm-dev-deps") {:dev true})))))))
    nil
    (:source-paths project)))

(defn read-node-deps-from-project
  [project]
  (let [{:keys [npm-deps npm-dev-deps]} project]
    (lein/info "lein-shadow - reading node dependencies from project.clj")
    (into
      (node-deps-map->vec npm-deps "project.clj!:npm-deps" {:dev false})
      (node-deps-map->vec npm-dev-deps "project.clj!:npm-dev-deps" {:dev true}))))

(defn read-deps-from-package-json
  [shadow-config]
  (let [file (package-json-file shadow-config)]
    (lein/info "lein-shadow - found existing package.json file at" (.getCanonicalPath file))
    (let [{:keys [dependencies devDependencies]} (-> file (slurp) (json/read-str :key-fn keyword))]
      (into
        (node-deps-map->vec dependencies (str (.getCanonicalPath file) "!:dependencies") {:dev false})
        (node-deps-map->vec devDependencies (str (.getCanonicalPath file) "!:devDependencies") {:dev true})))))

(defn create-empty-package-json!
  [project shadow-config]
  (let [file (package-json-file shadow-config)
        package-json-content (str "{\n  \"name\": \"" (package-json-name project) "\"\n}")]
    (lein/info "lein-shadow - creating empty package.json in" (package-install-dir shadow-config))
    (spit file package-json-content)))

(defn node-package-manager-rebuild-node_modules!
  [shadow-config]
  (let [command-type (node-package-manager shadow-config)
        command-args (if (= :yarn command-type)
                       ["add"]
                       (if (package-locks-exist? shadow-config)
                         ["ci"]
                         ["install"]))]
    (node-package-manager-sh! shadow-config "node package manager successfully built node_modules directory:\n" command-args)))

(defn node-package-manager-install-args
  [lein-node-deps package-json-deps]
  (reduce
    (fn [args {:keys [id version]}]
      (let [pred (fn [package-json-dep]
                   (when (and (= (name id) (name (:id package-json-dep)))
                              (= version)  (:version package-json-dep))
                     package-json-dep))]
        (if-let [{:keys [url] :as package-json-dep} (some pred package-json-deps)]
          (do
            (lein/info "lein-shadow - " (format "node package %s@%s already exists in %s." id version url))
            args)
          (do
            (lein/info "lein-shadow - " (format "node package %s@%s does not exist in %s. Adding." id version (or (:url (first package-json-deps) "package.json"))))
            (conj args (str (name id) "@" version))))))
    []
    lein-node-deps))

(defn node-package-manager-install-missing!
  [shadow-config package-json-deps lein-node-deps]
  (let [lein-node-dep-install-args      (-> (remove :dev lein-node-deps) (node-package-manager-install-args package-json-deps))
        lein-node-dev-deps-install-args (-> (filter :dev lein-node-deps) (node-package-manager-install-args package-json-deps))
        command-type                    (node-package-manager shadow-config)]
    (when (not-empty lein-node-dep-install-args)
      (node-package-manager-sh! shadow-config "node packages added successfully:\n"
                                (if (= :yarn command-type)
                                  (into ["add"] lein-node-dep-install-args ["--exact"])
                                  (into ["install" "--save" "--save-exact"] lein-node-dep-install-args))))
    (when (not-empty lein-node-dev-deps-install-args)
      (node-package-manager-sh! shadow-config "node dev packages added successfully:\n"
                                (if (= :yarn command-type)
                                  (into ["add"] lein-node-dev-deps-install-args ["--dev" "--exact"])
                                  (into ["install" "--save-dev" "--save-exact"] lein-node-dev-deps-install-args))))))

(defn node-deps!
 [project shadow-config]
 (node-package-manager-version! shadow-config)
 (let [package-json-deps (if (package-json-exists? shadow-config)
                           (read-deps-from-package-json shadow-config)
                           (do
                             (create-empty-package-json! project shadow-config)
                             []))

       lein-node-deps    (or (read-node-deps-from-deps-cljs project)
                             (read-node-deps-from-project project))]
   (when-not (empty? package-json-deps)
     (node-package-manager-rebuild-node_modules! shadow-config))

   (if-not (empty? lein-node-deps)
     (node-package-manager-install-missing! shadow-config package-json-deps lein-node-deps)
     (lein/info "lein-shadow - node packages not managed, skipping node package manager installs"))))


(defn overwrite-shadow-backup!
  []
  (let [shadow-config-file (io/file "shadow-cljs.edn")]
    (when (and (.exists shadow-config-file)
               (->> shadow-config-file
                    (slurp)
                    (re-find managed-regex)
                    (not)))
      (lein/warn "lein-shadow - unmanaged shadow-cljs.edn file exists. Backing up at " shadow-config-backup-path)
      (io/copy shadow-config-file (io/file shadow-config-backup-path)))))

(defn write-shadow-config!
  [shadow-config]
  (overwrite-shadow-backup!)
  (->> (assoc shadow-config :lein true)
       (pr-str)
       (str shadow-config-preamble)
       (spit "shadow-cljs.edn")))

(defn shadow!
  [project args]
  (lein/info "lein-shadow - running shadow-cljs...")
  (apply run/run project (concat run-shadow-cljs args)))

(defn shadow
  "Helps keep your project configuration in your `project.clj` file when using
   shadow-cljs.

   Refer to one of the following shadow-cljs documentation sources for exhaustive
   CLI args:
   - lein run -m shadow.cljs.devtools.cli --help
   - https://shadow-cljs.github.io/docs/UsersGuide.html

   Any command that can be run as `shadow-cljs <action> <zero or more build ids>`
   can be run via Leiningen with `lein shadow <action> <zero or more build ids>`.
   Some possibilities include:

   - lein shadow compile <one or more build ids>
   - lein shadow release <one or more build ids>
   - lein shadow watch   <one or more build ids>"
  [project & args]
  (if-not (first args)
    (lein/warn "lein-shadow - no action specified. See 'lein shadow --help'.")
    (if-let [shadow-config (:shadow-cljs project)]
      (let [shadow-default-config (read-default-shadow-config)
            shadow-config-merged  (merge-shadow-config shadow-default-config shadow-config)
            project-merged        (merge-project       shadow-default-config project)]
        (node-deps! project-merged shadow-config-merged)
        (write-shadow-config! shadow-config-merged)
        (shadow! project-merged args))
      (lein/warn "lein-shadow - no :shadow-cljs config key defined in project.clj. Please add a config to go into shadow-cljs.edn."))))
